<!doctype html>
<html>
<head>
	<title>Conway's Game of Life</title>
</head>
<body style="background-color: #ddd">
	<canvas id="game-canvas" style="display: block; margin: 100px auto 0 auto; background-color: #fff; image-rendering: pixelated;"></canvas>
	<script type="text/javascript">

		//get the game canvas context and set some other globals
		var size = 400;
		var framerate = 100;
		var josh = false;
		var eCanvas = document.getElementById("game-canvas");
		eCanvas.width = size;
		eCanvas.height = size;
		var cCanvas = eCanvas.getContext("2d");
		var mouseDown = false;
		var autoPlay = false;
		var lastX;
		var lastY;

		//create a new 2D array of falses (dead cells)
		var grid = new Array(size);
		for (var i=0; i<size; i++) {
			grid[i] = new Array(size);
			for (var j=0; j<size; j++) {
				grid[i][j] = false;
			}
		}

		//set the game to advance on pressing the spacebar (32)
		//set the game to toggle auto-play on pressing 'q' (81)
		document.onkeydown = function(e) {
			e = e || window.event;
			if (e.keyCode == 32 && gameReady) {
				advanceGame();
			} else if (e.keyCode == 81 && gameReady) {
				autoPlay = !autoPlay;
				if (autoPlay) {
					setTimeout(autoAdvance,10);
				}
			}
		}

		//set the game to place a cell on click
		eCanvas.onmousedown = function(e) {
			mouseDown = true;
			placeCellAtMouse(e,true)
			drawGame();
		}
		eCanvas.onmouseup = function(e) {
			mouseDown = false;
		}
		eCanvas.onmouseleave = function(e) {
			if (!josh) {
				mouseDown = false;
			}
		}
		eCanvas.onmousemove = function(e) {
			if (mouseDown) {
				placeCellAtMouse(e,false);
				drawGame();
			}
		}

		//set the game to ready
		gameReady = true;

		//advance the game by 1 step
		function advanceGame() {
			//create a new 2D array and fill it with the next states
			var newgrid = new Array(size);
			for (var i=0; i<size; i++) {
				newgrid[i] = new Array(size);
				for (var j=0; j<size; j++) {
					newgrid[i][j] = getNext(i,j);
				}
			}
			grid = newgrid;
			//draw the updated game
			drawGame();
		}

		//automatically advance the game
		function autoAdvance() {
			if (autoPlay) {
				advanceGame();
				setTimeout(autoAdvance,1000/framerate);
			}
		}

		//get the on/off state of the next step at this cell
		function getNext(x,y) {
			var sum = 0;
			for (var i = -1; i<=1; i++) {
				for (var j = -1; j<=1; j++) {
					sum += sample(x+i,y+j);
				}
			}
			if (grid[x][y] && (sum == 3 || sum == 4)) { //include self so 2/3 becomes 3/4
				return true;
			} else if (!grid[x][y] && sum == 3) {
				return true;
			} else {
				return false;
			}
		}

		//safely check the content of the given cell
		function sample(x,y) {
			//if (grid[x%size][y%size]) {
			//	return 1;
			//} else {
			//	return 0;
			//}
			//old version with bounds checking
			if (x<0 || x>= size || y<0 || y>=size || !grid[x][y]) {
				return 0;
			} else {
				console.log(typeof x);
				return 1;
			}
		}

		//draw the current game state
		function drawGame() {
			cCanvas.clearRect(0, 0, eCanvas.width, eCanvas.height);
			var gameImage = cCanvas.createImageData(size,size);
			var pixelColor;
			for (var i=0; i<size; i++) {
				for (var j=0; j<size; j++) {
					if (grid[i][j]) {
						pixelColor = 0;
					} else {
						pixelColor = 255;
					}
					gameImage.data[(i+j*size)*4+0] = pixelColor;
					gameImage.data[(i+j*size)*4+1] = pixelColor;
					gameImage.data[(i+j*size)*4+2] = pixelColor;
					gameImage.data[(i+j*size)*4+3] = 255;
				}
			}
			cCanvas.putImageData(gameImage,0,0);
		}

		//place (or remove) a cell at the position of the mouse pointer
		function placeCellAtMouse(e, ignoreLast) {
			var x;
			var y;
			if (e.pageX || e.pageY) {
				x = e.pageX;
				y = e.pageY;
			} else {
				x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
				y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			}
			x -= eCanvas.offsetLeft;
			y -= eCanvas.offsetTop;
			if (ignoreLast) {
				grid[x][y] = !grid[x][y];
			} else {
				drawGridLine(lastX,lastY,x,y,false);
			}
			lastX = x;
			lastY = y;
		}

		function drawGridLine(x0,y0,x1,y1,inverse) {
			var dx = x1 - x0;
			var dy = y1 - y0;
			if (Math.abs(dy) > Math.abs(dx)) {
				drawGridLine(y0,x0,y1,x1,true);
				return;
			}
			var error = -1.0;
			var derror = Math.abs(dy/dx);
			var x = x0;
			var y = y0;
			while (true) {
				if (x != x0) {
					if (!inverse) {
						grid[x][y] = !grid[x][y];
					} else {
						grid[y][x] = !grid[y][x];
					}
				}
				if (x == x1) {
					break;
				}
				x += 1*Math.sign(dx)
				error += derror;
				if (error >= 0) {
					error = error - 1;
					y = y + 1*Math.sign(dy);
				}
			}
		}
	</script>
</body>
</html>
